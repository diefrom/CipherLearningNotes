# 密码编码学与网络安全

tags： notes 加密解密

---
参考：
[密码学](http://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6)
[密码编码学与网络安全--原理与实践 第五版](http://item.jd.com/1060758614.html)

---
[TOC]

---
# 1、第二章 传统加密技术

* 密码编码学
密码编码学系统具有以下三个独立的特征：
1、 **转换明文为密文的运算类型。** 所有的加密算法都基于两个原理：代替和置换，代替是将明文中的每个元素（如位、字母、位组或字母组等）映射成另一个元素；置换是将明文中的元素重新排列。上述运算的基本要求是不允许有信息丢失（即所有的运算是可逆的）。大多数密码体质，也称为乘积密码系统，都使用了多层代替和置换。
2、 **所用的密钥数** 如果发送方和接收方使用相同的密钥，这种密码就称为对称密码、单密钥密码、秘密密钥密码或传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码、双钥或公钥密码。
3、 **处理明文的方法** 分组密码每次处理输入的一组元素，相应地输出一组元素。流密码则是连续地处理输入元素，每次输出一个元素。

---
* 明文：原始可理解的消息或数据，是算法的输入。

* 加密算法：加密算法对明文进行各种代替和替换。

* 密钥：密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。

* 密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同的密钥产生不同的密文，密文看上去是随机的数据流，并且意义是不可理解的。

* 解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。

---
* 对称密码是一种加解密使用相同密钥的密码体制，也称为传统密码。

* 对称密码利用密钥和加密算法将明文变为密文。运用相同的密钥和解密算法，可以从密文恢复成明文。

* 对称密码的两种攻击方法分别是基于密码算法性质的密码分析和基于穷举密钥的穷举攻击。

---
## 1.1 代替技术
* 代替技术：代替技术是将明文字母替换成其他字母、数字或符号的方法。如果把明文视为二进制的话，那么代替就是用密文位串来代替明文位串。已知最早的代替密码是有Julius Caesar发明的Caesar。

* Caesar密码

加密算法：
>    C = E(k, p) = (p + k) mod 26

解密算法
>    p = D(k, C) = (C - k) mod 26


其中，C是密文字母，p是明文字母，k是任意的移位且k的取值为[1, 25]

说白了，就是对应首尾相连的排序好的26个字母，将明文的每个字母右移k位后得到密文。

* just for fun: [caesar.c](https://github.com/diefrom/CipherLearningNotes/blob/master/caesar.c)

---
### 1.1.1 单表代替
* 单表代替密码：首先定义置换，有限元素的集合S的置换是S的所有元素的有序排列，且每个元素只出现一次。例如，如果S = {a， b， c}，则S有6个置换：abc，acb，bac，bca，cab，cba。一般，具有n个元素的集合有n!个置换。最著名的多字母代替密码是Playfair密码，它把明文中的双字母音节作为一个单元并将其转换成密文的“双字母音节”。

* Playfair密码

1、生成key
准备一个5*5的格子table，按照从左到右，从上到下的顺序可以向里面填写字母。
首先，去掉key中重复的字母，比如helloworld，变成helowrd，填入到格子table中。
然后，将26个字母按顺序填入到剩余的表格中，注意，这里也需要去掉重复的字母。
最后生成表格如下：
```
 h e l o w 
 r d z x v 
 a f b c g 
 i j k m n 
 p q s t u
```
 
2、加密
 （1）将明文字母两两组队，如果该字母对的两个字母是相同的，那么在它们之间加一个填充字母，比如x。例如对于ballon，应该拆分为ba lx lo on这样4个字母对。
 （2）落在矩阵同一行的明文字母对中的字母，由其右边的字母来代替，每行中最右边的一个字母就用该列中最左边的第一个字母来代替，比如明文字母对ow应该变成wh。
 （3）落在矩阵同一列的明文字母对中的字母，由其下面的字母来代替，每行中最下面的一个字母就用该列中最上面的第一个字母来代替，比如明文字母对hp应该变成rh。
 （4）其他的每组明文字母对中的字母按如下方式代替：对于每个字母，密文字母的行号和明文字母的行号相同，密文字母的列号是明文中另一个字母的行号，比如dm，变成xj。
 
* just for fun: 
[playfair.c](https://github.com/diefrom/CipherLearningNotes/blob/master/playfair.c)
[ba_playfair.c](https://github.com/diefrom/CipherLearningNotes/blob/master/ba_playfair.c)
 
* Hill密码
 二阶：主对调,次变号,除行列.
 三阶：除行列,别忘记,去一行,得一列,二变号,余不变,二三一,三一二,二三一,三一二.
 等借到线性代数书后，再看
 
---
### 1.1.2 多表代替
* 多表代替加密：对简单单表代替的改进方法是在明文消息中采用不同的单表代替。这种方法一般称之为多表代替密码。所有这些方法都有以下的共同特征：（1）采用相关的单表代替规则集。（2）密钥决定给定变换的具体规则。多表代替密码中最著名和最简单的是vigenere密码。
 
* vigenere密码

加密算法：

> C<sub>i</sub> = (p<sub>i</sub> + k<sub>i mod m</sub>) mod 26

解密算法：

> p<sub>i</sub> = (C<sub>i</sub>  - k<sub>i mod m</sub>) mod 26

* just for fun: [vigenere.c](https://github.com/diefrom/CipherLearningNotes/blob/master/vigenere.c)

---
### 1.1.3 一次一密

使用与消息一样长且无重复的随机密钥来加密消息，另外，密钥只对一个消息进行加密，之后丢弃不用。每一条新消息都需要一个与其等长的新密钥。一次一密实际很少用，主要用于安全性要求很高的低宽带信道。一次一密是唯一的具有完善保密的密码体制。

---
## 1.2 置换技术
* 置换技术：对明文进行置换的密码叫做置换密码。

* 栅栏技术

最简单的置换技术是栅栏技术，按照对角线的顺序写出明文，而按行的顺序独处作为密文，例如，用深度为2的栅栏技术加密信息“meet me after the toga party”，可写为：
```
 m e m a t r h t g p r y
  e t e f e t e o a a t
```
加密后的信息是MEMATRHTGPRYETEFEFETEOAAT

* 矩形块

一个更复杂的方案是把消息一行一行地写成矩形块，然后按列独处，但是把列的次序打乱。列的次序就是算法的密钥。例如：
```
密钥： 4 3 1 2 5 6 7
明文： a t t a c k p
       o s t p o n e
       d u n t i l t
       w o a m x y z
```
密文：TTNAAPTMTSUOAODWCOIXKNLYPETZ
多次置换密码相对来讲要安全得多。这种复杂的置换是不容易重构的。上面的这条消息还可以用相同的算法再加密一次。
```
密钥： 4 3 1 2 5 6 7
明文： t t n a a p t
       m t s u o a o
       d w c o i x k
       n l y p e t z
```
密文：NSCYAUOPTTWLTMDNAOIEPAXTTOKZ

---
# 2、 第三章 分组密码和数据加密标准

* 分组密码是一种加/解密方案，它将输入的明文分组当做一个整体处理，输出一个等长的密文分组。
* 事实上，现在使用的大多数对称分组加密算法都是基于Feistel分组密码结构的[FEIS73].
* 流密码每次加密数据流的一位或一个字节。
* 分组密码是将一个明文分组作为整体加密并且通常得到的是与明文等长的分组密文。典型的分组大小是64位或128位。
* 加密是可逆的（即可以解密），每一个明文分组将唯一对应一个密文分组。这样的变换成为可逆变换，或非奇异变换。

---
## 2.1 Feistel密码

Feistel建议使用这样的密码：该种密码交替地使用代替和置换。

* Feistel结构
加密算法的输入是长为2w位的明文分组和密钥K。明文分组被分为等长的两部分：L<sub>0</sub>和R<sub>0</sub>。者两半数据经过n轮迭代后组合成密文分组。第i轮迭代的输入L<sub>i-1</sub>和R<sub>i-1</sub>来自于上轮迭代的输出；而输入的子密钥K<sub>i</sub>是有整个密钥K推导出的。一般地，K<sub>i</sub>不同与K，也互不相同。

Feistel结构的具体实现依赖于一下参数和特征：
1） 分组长度：分组越长越安全，但会降低加/解密的速度。常用分组长度64位，高级加密使用128位。
2） 密钥长度：密钥越长越安全，但会降低加/解密的速度。通常使用128位密钥长度。
3） 迭代轮数：Feistel密码的本质在于单轮不能提供足够的安全性，多轮加密可取得很高的安全性。迭代轮数的典型值是16。
4） 子密钥产生算法：子密钥产生越复杂，密码分析就越困难。
5） 轮函数F：轮函数越复杂，抗攻击能力就越强。
6） 快速软件加/解密：许多情况下，加密算法嵌入到应用程序中，来避免硬件实现的麻烦，因此，算法执行的速度很重要。
7） 简化分析难度：如果算法描述起来简洁清楚，那么分析其脆弱性也就容易一些，因而可以开发出更强的算法。

  




